import java.util.concurrent.Callable
import java.util.concurrent.Executor
import java.util.concurrent.Executors

apply plugin: 'java'
apply plugin: 'docker-compose'

buildscript {
    repositories {
        jcenter()
    }
    dependencies {
        classpath "com.avast.gradle:gradle-docker-compose-plugin:0.8.13"
    }
}

repositories {
    mavenCentral()
}

def SERVICE_NAME = "myservice"
def EVENT_PATH = "event.json"
def LOCAL_STACK_CONTAINER_NAME = "ls-myservice"
def NETWORK_NAME = "serverless"


sourceCompatibility = 1.8
targetCompatibility = 1.8

dependencies {
    compile(
            'com.amazonaws:aws-lambda-java-core:1.1.0',
            'com.amazonaws:aws-lambda-java-log4j:1.0.0',
            'com.fasterxml.jackson.core:jackson-core:2.8.5',
            'com.fasterxml.jackson.core:jackson-databind:2.8.5',
            'com.fasterxml.jackson.core:jackson-annotations:2.8.5'
    )
    compile group: 'com.amazonaws', name: 'aws-java-sdk-dynamodb', version: '1.11.534'


}

jar {
    from(configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }) {
        exclude "META-INF/*.SF"
        exclude "META-INF/*.DSA"
        exclude "META-INF/*.RSA"
    }

    manifest {
    }
}

task buildZip(type: Zip) {
    from compileJava
    from processResources
    into('lib') {
        from configurations.runtime
    }
}

task copyClassesToLocalRunFolder(type: Copy) {
    from(sourceSets.main.output) {
        exclude "META-INF/*.SF"
        exclude "META-INF/*.DSA"
        exclude "META-INF/*.RSA"
    }
    into buildDir.path + "/run"
}

task copyDependenciesToLocalRunFolder(type: Copy) {
    from(configurations.compile.collect { it.isDirectory() ? it : zipTree(it) }) {
        exclude "META-INF/*.SF"
        exclude "META-INF/*.DSA"
        exclude "META-INF/*.RSA"
    }
    into buildDir.path + "/run"
}


task runLocalLambda() {

    doLast{

        def portForLambda = getAvailablePort()

        Executor executor = Executors.newSingleThreadExecutor()

        def commandTemplate = "sam local invoke -d %s %s -e %s --docker-network host"
        def command = String.format(commandTemplate, portForLambda, SERVICE_NAME, EVENT_PATH)
        println command

        executor.submit({command.execute().text} as Callable<Void>)
        println "Waiting on port: " + portForLambda
    }
}


dockerCompose {

    useComposeFiles = ["./docker-compose.yml"]
    startedServices = ['localstack']
    forceRecreate = false
    buildBeforeUp = true
    buildBeforePull = true
    ignorePushFailure = false
    buildAdditionalArgs = ['--force-rm']

    //logging
    captureContainersOutput = false
    captureContainersOutputToFile = "${buildDir.path}/logs/all_container_logs.txt"
    //separate logs for all the containers
    containerLogToDir = project.file("${buildDir.path}/logs")
    captureContainersOutputToFiles = "${buildDir.path}/logs/separated"

    waitForTcpPorts = true

    removeContainers = true
    removeImages = "local"
    removeVolumes = true
    removeOrphans = true
    environment.put 'LOCAL_STACK_CONTAINER_NAME', "${LOCAL_STACK_CONTAINER_NAME}"
    environment.put 'NETWORK_NAME', "${NETWORK_NAME}"
}

def static getAvailablePort() {
    if (System.properties['os.name'].toLowerCase().contains('windows')) {
        ServerSocket s = new ServerSocket(0)
        return s.getLocalPort()
    } else {
        return 37777
    }
}

build.dependsOn buildZip
runLocalLambda.dependsOn build
runLocalLambda.dependsOn copyDependenciesToLocalRunFolder
runLocalLambda.dependsOn copyClassesToLocalRunFolder
runLocalLambda.dependsOn composeUp
copyDependenciesToLocalRunFolder.mustRunAfter build

copyClassesToLocalRunFolder.mustRunAfter build
